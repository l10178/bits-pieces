# 正则表达式从入门到放弃

首先来看几个问题：

1. 假设有一个字符串“a b c”\(中间是一个空格\)，想实现按空格分割成一个数组\["a","b","c"\]，用Java或JavaScript代码如何实现。
2. 原始数组改成"a  b c"\(中间是N个空格\)，仍分割成数组\["a","b","c"\]，如何实现。

```java
    @Test
    public void testSplit() {
        String dotStr = "a.b.c";
        assertEquals(dotStr.split(".").length, 0);
        assertEquals(dotStr.split("\\.").length, 3);

        String spaceStr="a  b c";//a与b之间两个空格,b与c之间一个空格
        assertEquals(spaceStr.split(" ").length, 4);//一个空格
        assertEquals(spaceStr.split(" +").length, 3);//一个或多个空格
        assertEquals("a b c".split(" +").length, 3);//一个或多个空格
        assertEquals("a  b    c".split(" +").length, 3);//一个或多个空格

        //顺便提一句,与正则无关,注意下面这个结果,这是Java的split方法自己处理的
        assertEquals("a b c   ".split(" ").length, 3);//split会去除最后为空的结果
        assertEquals(" a b c".split(" ").length, 4);//split不会去除前面为空的结果
    }
```

以上就是一个正则的简单应用，其实平时工作中除了编程我们也会经常用到正则，比如搜索所有Word文档（\*.doc）,在文本编辑器中搜索和替换文字等等。正则表达式经过数年的发展，已经逐渐从模糊而深奥的数学概念，发展成为在计算机各类工具和软件包应用中的主要功能，成为人们工作中的一个利器。

## 什么是正则表达式

正则表达式（Regular Expression，regex、regexp，以下简称正则）是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。

完整的正则表达式由两种字符构成，特殊字符（又译元字符）和普通文字。如果把正则表达式想象成普通的语言，普通文字相当于语言中的单词，而元字符相当于语法。就像一门语言一样，正则是烦琐而强大的，学会之后的应用会让你除了提高效率外，会给你带来绝对的成就感。只要坚持去学，一定会放弃的。

## 正则引擎

引擎就相当于语言的编译器，解释器，用来对正则进行语法分析。不同的引擎决定了某个正则能否匹配、在何处匹配，以及匹配成功或报告失败的速度，另外知道正则表达式引擎是如何工作的有助于理解为何某个正则表达式在一个平台好用，换个平台就不好使了。

正则引擎主要可以分为两大类：一种是DFA，一种是NFA。先别管这两个的含义，只需要知道这两个名字。这两种引擎都有了很长的历史，当中也由这两种引擎产生了很多变体。后来又出了一个POSIX标准，用来规范这种现象。DFA是符合这种标准的，NFA不符合，这样一来，主流的正则引擎又分为3类：DFA，传统型NFA，POSIX NFA。

关于DFA和NFA的详细区别，在这里先不提了，因为正则本身就是一个很难懂的语言，一下子提这么多怕大家真的放弃了。但是要了解一点，不同的引擎不同的写法，速度是不一样的，如果对性能要求高的话，还是需要了解引擎的实现方式。Java和JavaScript都是NFA类型。除去引擎的不同，不同的语言对正则的实现也有差异，所以下面所有的语法和实例，多以Java为主，尽量兼顾JavaScript，不考虑Python、C++、Swift等其他语言。

## 基础语法

| 元字符 | 说明 |
| :--- | :--- |
| ^ | 匹配输入字符串开始的位置。 |
| $ | 匹配输入字符串结尾的位置。 |
| _ | 零次或多次匹配前面的字符或子表达式。例如，zo_ 匹配"z"和"zoo"。\* 等效于 {0,}。 |
| + | 一次或多次匹配前面的字符或子表达式。例如，"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。 |
| ? | 零次或一次匹配前面的字符或子表达式。例如，"do\(es\)?"匹配"do"或"does"中的"do"。? 等效于 {0,1}。 |
| {n} | n 是非负整数。正好匹配 n 次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。 |
| {n,} | n 是非负整数。至少匹配 n 次。例如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有 o。"o{1,}"等效于"o+"。"o{0,}"等效于"o\*"。 |
| {n,m} | M 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。注意：您不能将空格插入逗号和数字之间。 |
| ? | 当此字符紧随任何其他限定符（\*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。 |
| . | 匹配除"\r\n"之外的任何单个字符。若要匹配包括"\r\n"在内的任意字符，请使用诸如"\[\s\S\]"之类的模式。 |
| \(pattern\) | 匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果"匹配"集合中检索捕获的匹配。若要匹配括号字符 \( \)，请使用"\("或者"\)"。 |
| x│y | 匹配 x 或 y。例如'\(z│f\)ood' 匹配"zood"或"food"。|
| [xyz] | 字符集。匹配包含的任一字符。例如，"\[abc\]"匹配"plain"中的"a"。 |
| \[^xyz\] | 反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。|
| [a-z] | 字符范围。匹配指定范围内的任何字符。例如，"\[a-z\]"匹配"a"到"z"范围内的任何小写字母。  |
| \[^a-z] | 反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。 |
| \b | 匹配一个字边界，即字与空格间的位置。例如，"er\b"匹配"never"中的"er"，但不匹配"verb"中的"er"。 |
| \B | 非字边界匹配。"er\B"匹配"verb"中的"er"，但不匹配"never"中的"er"。 |
| \d | 数字字符匹配。等效于 \[0-9\]。 |
| \D | 非数字字符匹配。等效于 [^0-9]。 |
| \f | 换页符匹配。等效于 \x0c 和 \cL。 |
| \n | 换行符匹配。等效于 \x0a 和 \cJ。 |
| \r | 匹配一个回车符。等效于 \x0d 和 \cM。 |
| \s | 匹配任何空白字符，包括空格、制表符、换页符等。 |
| \S | 匹配任何非空白字符。 |
| \t | 制表符匹配。 |
| \w | 匹配任何字类字符，包括下划线。与"\[A-Za-z0-9\_\]"等效。 |
| \W | 与任何非单词字符匹配。与"[^A-Za-z0-9_]"等效。 |

## 运算符优先级

正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序.

## 实例
Java、JavaScript、Shell
