<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on bits-pieces</title><link>https://l10178.github.io/bits-pieces/linux/</link><description>Recent content in Linux on bits-pieces</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 29 Jan 2021 23:54:37 +0800</lastBuildDate><atom:link href="https://l10178.github.io/bits-pieces/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Git常用配置</title><link>https://l10178.github.io/bits-pieces/linux/git/</link><pubDate>Thu, 09 Mar 2023 23:54:37 +0800</pubDate><guid>https://l10178.github.io/bits-pieces/linux/git/</guid><description>Git 多用户配置 Git 给不同目录配置不同的 config，比如区分个人开发账号和公司开发账号。
为账户 B 准备一个单独的配置文件，比如： ~/.gitconfig-b，内容根据需要定义。
[user] name = userb-name email = userb-email@test.com 修改 ~/.gitconfig 文件，增加以下配置，引用上面创建的配置文件，注意用绝对路径，并且路径以 / 结尾。
[includeIf &amp;#34;gitdir:/project/path-b/&amp;#34;] path = /Users/xxxx/.gitconfig-b 保存后，在 /project/path-b/ 下新的仓库都会以 .gitconfig-b 中的用户名和邮箱提交了。</description></item><item><title>History入门</title><link>https://l10178.github.io/bits-pieces/linux/history/</link><pubDate>Fri, 29 Jan 2021 23:54:37 +0800</pubDate><guid>https://l10178.github.io/bits-pieces/linux/history/</guid><description>Linux 下 history 命令，用好历史命令提高工作效率。
搜索历史命令 快捷键 Ctrl + r
非常建议你使用这个命令, 因为当你曾经输过一个很长的命令之后, 当你再次想输入这个命令的时候, 你就可以按下这个快捷键, 然后键入那条长命令的关键词, 然后就会显示出含有那个关键词的命令, 每次按下这个键都会再往上搜一个。可以找个机器实际体会下，确实很常用。
重复上一次的命令 向上的方向键。上下键翻看历史命令，翻到想执行的命令回车。
两个叹号: ！！
还有这个：！-1
快捷键：Ctrl+p 或 Ctrl+n，向上和向下翻看历史命令，和上下键效果一样。
从历史记录中执行某个命令 还是沿袭上一个中的 !-n 模式, 其中 n 是一个编号。如下示例，执行了编号为 4 的命令。
1 service network restart 2 exit 3 id 4 cat /etc/redhat-release # !4 cat /etc/redhat-release 执行曾经的命令中特定开头的 假设你的部分历史命令如下:
1721 find . -type f 那么, 怎样重复执行 1721 条呢? 除了利用 !-1721 这么麻烦的方法，我们还可以用 !f 这样的姿势。因为开头的 f 是离着最后一条命令最近的, 所以 !f 就执行了它。
清空历史记录 history -c 在历史记录中显示时间 我们可以用 HISTTIMEFORMAT 这个变量来定义显示历史记录时的时间参数:</description></item><item><title>Shell 编程实用句式</title><link>https://l10178.github.io/bits-pieces/linux/shell-coding/</link><pubDate>Fri, 29 Jan 2021 23:54:37 +0800</pubDate><guid>https://l10178.github.io/bits-pieces/linux/shell-coding/</guid><description>选婿。
#!/usr/bin/env bash #!/usr/bin/bash 检查是否以 root 用户执行。
# check if run as root user if [[ `id -u` -ne 0 ]]; then echo &amp;#34;You need root privileges to run this script.&amp;#34; fi 获取正在执行脚本的绝对路径，注意直接用 $0 或 pwd 获取的可能都不要你想要的。
current_dir=$(cd `dirname $0`;pwd) 为当前目录包含子目录下所有 .sh 文件增加可执行权限。
chmod +x `find . -name &amp;#39;*.sh&amp;#39;` 将提示信息显示到终端（控制台），同时也写入到文件里。
log_file=/var/log/test.log echo &amp;#34;This line will echo to console and also write to log file.&amp;#34; | tee -a ${log_file} 类似于 Java properties 中 key=value 形式的字符串，取 key 和 value 的值。</description></item><item><title>tcpdump</title><link>https://l10178.github.io/bits-pieces/linux/tcpdump/</link><pubDate>Fri, 29 Jan 2021 23:54:37 +0800</pubDate><guid>https://l10178.github.io/bits-pieces/linux/tcpdump/</guid><description>tcpdump 捕捉网卡eth0流量，并存入到out.pcap文件中。
sudo tcpdump -vv -s0 -i eth0 -w out.pcap</description></item><item><title>文件压缩解压</title><link>https://l10178.github.io/bits-pieces/linux/tar.gz/</link><pubDate>Fri, 29 Jan 2021 23:54:37 +0800</pubDate><guid>https://l10178.github.io/bits-pieces/linux/tar.gz/</guid><description>常用文件格式 .tar：tar 其实打包（或翻译为归档）文件，本身并没有压缩。在 Linux 里 man tar 可以看到它的描述也是“manipulate tape archives”（tar 最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案，只是它的描述还没有改）。
.gz：gzip 是 GNU 组织开发的一个压缩程序，.gz 结尾的文件就是 gzip 压缩的结果。
.bz2：bzip2 是一个压缩能力更强的压缩程序，.bz2 结尾的文件就是 bzip2 压缩的结果。
.Z：compress 也是一个压缩程序。.Z 结尾的文件就是 compress 压缩的结果。
.zip：使用 zip 软件压缩的文件。
.tar.gz、.tar.bz2、.tar.xz 等可以理解为打包+压缩的效果，用软件解压可以发现比.gz 多了一层包。gzip 和 bzip2，不能同时压缩多个文件，tar 相当于开个挂加上同时压缩的特效，tar 先归档为一个大文件，而归档为大文件的速度是很快的，测试了一下几乎可以忽略不计。
除了这些格式外，常见的 deb、exe、msi、rpm、dmg、iso 等安装软件，其实都是经过压缩的，一般情况下没有必要再压缩。而 rar 基本认为是 Windows 平台专属的压缩算法了，各个 Linux 发行版都不自带 rar 压缩解压缩软件，所以可以看到很多软件发行的格式都是 .tar.gz 或 .zip。
解压缩 根据文件名后缀自行选择解压缩命令。
tar -xf test.tar gzip -d test.gz gunzip test.gz # -C 直接解压到指定目录 tar -xzf test.tar.gz -C /home bzip2 -d test.</description></item><item><title>PNG图片批量压缩</title><link>https://l10178.github.io/bits-pieces/linux/pngquant/</link><pubDate>Mon, 14 Dec 2020 23:54:37 +0800</pubDate><guid>https://l10178.github.io/bits-pieces/linux/pngquant/</guid><description>使用 pngquant 命令行批量压缩 PNG 图片。
pngquant 压缩当前目录下全部 PNG 文件，并且默认全覆盖已有。
for file in $(ls *.png) do pngquant $file --force --output $file done</description></item><item><title>数据库事务控制</title><link>https://l10178.github.io/bits-pieces/linux/transaction/</link><pubDate>Mon, 14 Dec 2020 23:54:37 +0800</pubDate><guid>https://l10178.github.io/bits-pieces/linux/transaction/</guid><description>数据库事务总结，主要包括数据库事务 ACID 属性介绍、数据库并发问题总结、事务传播行为和隔离级别。
概念 事务（Transaction）是并发控制的基本单位。它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。标准定义：指作为单个逻辑工作单元执行的一系列操作，而这些逻辑工作单元需要具有原子性， 一致性，隔离性和持久性四个属性，统称为 ACID 特性。
Atomic（原子性） 事务中包含的操作被看做一个不可分割的逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。
Consistency（一致性） 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。关于数据库一致性，更专业的解释请参考专业的书籍。
Isolation（隔离性） 事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。
Durability（持久性） 事务提交后，对系统的影响是永久的。简单理解就是写进去了，不会因为时间、系统环境，关机重启等变化而变化。
数据库并发问题 数据库是共享资源，通常有许多个事务同时在运行。当多个事务并发地存取数据库时就会产生同时读取和（或）修改同一数据的情况。若对并发操作不加控制就可能会存取和存储不正确的数据，破坏数据库的一致性。所以数据库管理系统必须提供并发控制机制。
并发操作一般可能带来以下几种问题。为说明问题，先来准备一个例子，假设现在有一个账户表 TBL_BANK_ACCOUNT。
CREATE TABLE TBL_BANK_ACCOUNT（ AccountId CHAR(4) NOT NULL, -- 银行账号 Username NVARCHAR(63) NOT NULL, -- 用户名 Balance BIGINT NOT NULL -- 余额 ) INSERT INTO TBL_BANK_ACCOUNT VALUES (&amp;#39;9555&amp;#39;, &amp;#39;小明&amp;#39;, 1000) -- 北京分行账号 INSERT INTO dbo.BankAccount VALUES (&amp;#39;9556&amp;#39;, &amp;#39;小明&amp;#39;, 2000) -- 上海分行账号 脏读（Dirty reads） 一个事务读到另一个事务未提交的更新数据。
事务 1 取款事务 事务 2 工资转账事务 开始事务 开始事务 查询余额 1000 元 取出 100 变为 900 查询余额为 900 异常发生，事务回滚，余额恢复为 1000 汇入工资 2000 元，余额为 2900 提交事务，最终余额 2900，损失了 100 不可重复读（Non-Repeatable Reads） 在同一个事务内，读取表中的某一行记录，多次读取的结果不同。与幻读区别的重点在于修改，同样的条件，已经读取过的数据，再次读取出来和上一次的值不一样。</description></item><item><title/><link>https://l10178.github.io/bits-pieces/linux/regular-expressions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://l10178.github.io/bits-pieces/linux/regular-expressions/</guid><description>正则表达式从入门到放弃 首先来看几个问题：
假设有一个字符串“a b c”(中间是一个空格)，想实现按空格分割成一个数组[&amp;ldquo;a&amp;rdquo;,&amp;ldquo;b&amp;rdquo;,&amp;ldquo;c&amp;rdquo;]，用 Java 或 JavaScript 代码如何实现。 原始数组改成&amp;quot;a b c&amp;quot;(中间是 N 个空格)，仍分割成数组[&amp;ldquo;a&amp;rdquo;,&amp;ldquo;b&amp;rdquo;,&amp;ldquo;c&amp;rdquo;]，如何实现。 @Test public void testSplit() { String dotStr = &amp;#34;a.b.c&amp;#34;; assertEquals(dotStr.split(&amp;#34;.&amp;#34;).length, 0); assertEquals(dotStr.split(&amp;#34;\\.&amp;#34;).length, 3); String spaceStr=&amp;#34;a b c&amp;#34;;//a与b之间两个空格,b与c之间一个空格 assertEquals(spaceStr.split(&amp;#34; &amp;#34;).length, 4);//一个空格 assertEquals(spaceStr.split(&amp;#34; +&amp;#34;).length, 3);//一个或多个空格 assertEquals(&amp;#34;a b c&amp;#34;.split(&amp;#34; +&amp;#34;).length, 3);//一个或多个空格 assertEquals(&amp;#34;a b c&amp;#34;.split(&amp;#34; +&amp;#34;).length, 3);//一个或多个空格 //顺便提一句,与正则无关,注意下面这个结果,这是Java的split方法自己处理的 assertEquals(&amp;#34;a b c &amp;#34;.split(&amp;#34; &amp;#34;).length, 3);//split会去除最后为空的结果 assertEquals(&amp;#34; a b c&amp;#34;.split(&amp;#34; &amp;#34;).length, 4);//split不会去除前面为空的结果 } 以上就是一个正则的简单应用，其实平时工作中除了编程我们也会经常用到正则，比如搜索所有 Word 文档（*.</description></item></channel></rss>