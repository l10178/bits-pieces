<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>数据库事务控制 | bits-pieces</title><link rel=icon href=/bits-pieces/favicon/favicon-32x32.png type=image/x-icon><link rel=stylesheet href=/bits-pieces/main.min.css media=screen><link rel=stylesheet href=/bits-pieces/custom.css media=screen></head><body><div class=wrapper><input type=checkbox class=hidden id=menu-control><header class=gdoc-header><div class="container flex align-center justify-between"><label for=menu-control class=gdoc-nav__control><svg class="icon menu"><use xlink:href="#menu"/></svg><svg class="icon arrow-back"><use xlink:href="#arrow_back"/></svg></label><a class=gdoc-header__link href=https://l10178.github.io/bits-pieces/><span class="gdoc-brand flex align-center"><img class=gdoc-brand__img src=/bits-pieces/images/logos/logo.png alt=bits-pieces width=38 height=38>
bits-pieces</span></a></div></header><main class="container flex flex-even"><aside class=gdoc-nav><nav><div class=gdoc-search><svg class="icon search"><use xlink:href="#search"/></svg><input type=text id=gdoc-search-input class=gdoc-search__input placeholder=Search... aria-label=Search maxlength=64><div class="gdoc-search__spinner spinner hidden"></div><ul id=gdoc-search-results class=gdoc-search__list></ul></div><section class=gdoc-nav--main><h2>Navigation</h2><ul class=gdoc-nav__list><li><span class=flex><a href=/bits-pieces/devops/ class=gdoc-nav__entry>DevOps</a></span><ul class=gdoc-nav__list><li><span class=flex><a href=/bits-pieces/devops/mysql5.7to8.0/ class=gdoc-nav__entry>MySQL5.7升级至8.0</a></span></li><li><span class=flex><a href=/bits-pieces/devops/mysql-large-import/ class=gdoc-nav__entry>MySQL大文件导入优化</a></span></li><li><span class=flex><a href=/bits-pieces/devops/nexus/ class=gdoc-nav__entry>Nexus3 批量导入</a></span></li><li><span class=flex><a href=/bits-pieces/devops/superset/ class=gdoc-nav__entry>Superset 对接 ClickHouse</a></span></li><li><span class=flex><a href=/bits-pieces/devops/cdr/ class=gdoc-nav__entry>使用Visual Studio Code搭建多用户远程IDE</a></span></li></ul></li><li><span class=flex>Javas</span><ul class=gdoc-nav__list><li><span class=flex><a href=/bits-pieces/java/jvm/ class=gdoc-nav__entry>Java进程内存分析</a></span></li><li><span class=flex><a href=/bits-pieces/java/spring-start-site/ class=gdoc-nav__entry>Spring Start脚手架快速入门</a></span></li></ul></li><li><span class=flex>Kubernetes</span><ul class=gdoc-nav__list><li><span class=flex><a href=/bits-pieces/kubernetes/envoy/ class=gdoc-nav__entry>Envoy生产配置最佳实践</a></span></li><li><span class=flex><a href=/bits-pieces/kubernetes/tldr/ class=gdoc-nav__entry>TL;DR</a></span></li><li><span class=flex><a href=/bits-pieces/kubernetes/cka/ class=gdoc-nav__entry>备考 CKA 过程，CKA 真题</a></span></li></ul></li><li><span class=flex><a href=/bits-pieces/linux/ class=gdoc-nav__entry>Linux</a></span><ul class=gdoc-nav__list><li><span class=flex><a href=/bits-pieces/linux/regular-expressions/ class=gdoc-nav__entry>Regular Expressions</a></span></li><li><span class=flex><a href=/bits-pieces/linux/history/ class=gdoc-nav__entry>History入门</a></span></li><li><span class=flex><a href=/bits-pieces/linux/pngquant/ class=gdoc-nav__entry>PNG图片批量压缩</a></span></li><li><span class=flex><a href=/bits-pieces/linux/shell-coding/ class=gdoc-nav__entry>Shell 编程实用句式</a></span></li><li><span class=flex><a href=/bits-pieces/linux/tcpdump/ class=gdoc-nav__entry>tcpdump</a></span></li><li><span class=flex><a href=/bits-pieces/linux/transaction/ class="gdoc-nav__entry is-active">数据库事务控制</a></span></li><li><span class=flex><a href=/bits-pieces/linux/tar.gz/ class=gdoc-nav__entry>文件压缩解压</a></span></li></ul></li><li><span class=flex><a href=/bits-pieces/windows/ class=gdoc-nav__entry>Windows</a></span><ul class=gdoc-nav__list><li><span class=flex><a href=/bits-pieces/windows/takeown/ class=gdoc-nav__entry>Windows提权 + 设置环境变量</a></span></li></ul></li><li><span class=flex><a href=/bits-pieces/knives/ class=gdoc-nav__entry>瑞士军刀</a></span><ul class=gdoc-nav__list><li><span class=flex><a href=/bits-pieces/knives/ripgrep/ class=gdoc-nav__entry>ripgrep</a></span></li><li><span class=flex><a href=/bits-pieces/knives/tldr/ class=gdoc-nav__entry>TL;DR</a></span></li></ul></li></ul></section><section class=gdoc-nav--more><h2>More</h2><ul class=gdoc-nav__list><li><span class=flex><svg class="icon download"><use xlink:href="#download"/></svg><a href=https://github.com/l10178/bits-pieces/releases class=gdoc-nav__entry>Releases</a></span></li><li><span class=flex><svg class="icon github"><use xlink:href="#github"/></svg><a href=https://github.com/l10178/bits-pieces class=gdoc-nav__entry>View Source</a></span></li></ul></section></nav></aside><div class=gdoc-page><div class="gdoc-page__header flex flex-wrap justify-between" itemscope itemtype=https://schema.org/Breadcrumb><span></span><span><svg class="icon code"><use xlink:href="#code"/></svg><a href=https://github.com/l10178/bits-pieces/edit/main/content/linux/transaction.md>Edit this page</a></span></div><article class=gdoc-markdown><h1>数据库事务控制</h1><p>数据库事务总结，主要包括数据库事务 ACID 属性介绍、数据库并发问题总结、事务传播行为和隔离级别。</p><div class=gdoc-page__anchorwrap><h2 id=概念>概念<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#概念 class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 概念" href=#概念><svg class="icon link"><use xlink:href="#link"/></svg></a></h2></div><p>事务（Transaction）是并发控制的基本单位。它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。标准定义：指作为单个逻辑工作单元执行的一系列操作，而这些逻辑工作单元需要具有原子性， 一致性，隔离性和持久性四个属性，统称为 ACID 特性。</p><div class=gdoc-page__anchorwrap><h3 id=atomic原子性>Atomic（原子性）<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#atomic原子性 class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor Atomic（原子性）" href=#atomic原子性><svg class="icon link"><use xlink:href="#link"/></svg></a></h3></div><p>事务中包含的操作被看做一个不可分割的逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。</p><div class=gdoc-page__anchorwrap><h3 id=consistency一致性>Consistency（一致性）<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#consistency一致性 class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor Consistency（一致性）" href=#consistency一致性><svg class="icon link"><use xlink:href="#link"/></svg></a></h3></div><p>事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。关于数据库一致性，更专业的解释请参考专业的书籍。</p><div class=gdoc-page__anchorwrap><h3 id=isolation隔离性>Isolation（隔离性）<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#isolation隔离性 class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor Isolation（隔离性）" href=#isolation隔离性><svg class="icon link"><use xlink:href="#link"/></svg></a></h3></div><p>事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。</p><div class=gdoc-page__anchorwrap><h3 id=durability持久性>Durability（持久性）<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#durability持久性 class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor Durability（持久性）" href=#durability持久性><svg class="icon link"><use xlink:href="#link"/></svg></a></h3></div><p>事务提交后，对系统的影响是永久的。简单理解就是写进去了，不会因为时间、系统环境，关机重启等变化而变化。</p><div class=gdoc-page__anchorwrap><h2 id=数据库并发问题>数据库并发问题<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#数据库并发问题 class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 数据库并发问题" href=#数据库并发问题><svg class="icon link"><use xlink:href="#link"/></svg></a></h2></div><p>数据库是共享资源，通常有许多个事务同时在运行。当多个事务并发地存取数据库时就会产生同时读取和（或）修改同一数据的情况。若对并发操作不加控制就可能会存取和存储不正确的数据，破坏数据库的一致性。所以数据库管理系统必须提供并发控制机制。</p><p>并发操作一般可能带来以下几种问题。为说明问题，先来准备一个例子，假设现在有一个账户表 TBL_BANK_ACCOUNT。</p><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>CREATE</span> <span class=k>TABLE</span> <span class=n>TBL_BANK_ACCOUNT</span><span class=err>（</span>
<span class=n>AccountId</span> <span class=nb>CHAR</span><span class=p>(</span><span class=mi>4</span><span class=p>)</span> <span class=k>NOT</span> <span class=k>NULL</span><span class=p>,</span> <span class=c1>-- 银行账号
</span><span class=c1></span><span class=n>Username</span> <span class=n>NVARCHAR</span><span class=p>(</span><span class=mi>63</span><span class=p>)</span> <span class=k>NOT</span> <span class=k>NULL</span><span class=p>,</span> <span class=c1>-- 用户名
</span><span class=c1></span><span class=n>Balance</span> <span class=nb>BIGINT</span> <span class=k>NOT</span> <span class=k>NULL</span> <span class=c1>-- 余额
</span><span class=c1></span><span class=p>)</span>
<span class=k>INSERT</span> <span class=k>INTO</span> <span class=n>TBL_BANK_ACCOUNT</span>
<span class=k>VALUES</span> <span class=p>(</span><span class=s1>&#39;9555&#39;</span><span class=p>,</span> <span class=s1>&#39;小明&#39;</span><span class=p>,</span> <span class=mi>1000</span><span class=p>)</span> <span class=c1>-- 北京分行账号
</span><span class=c1></span><span class=k>INSERT</span> <span class=k>INTO</span> <span class=n>dbo</span><span class=p>.</span><span class=n>BankAccount</span>
<span class=k>VALUES</span> <span class=p>(</span><span class=s1>&#39;9556&#39;</span><span class=p>,</span> <span class=s1>&#39;小明&#39;</span><span class=p>,</span> <span class=mi>2000</span><span class=p>)</span> <span class=c1>-- 上海分行账号
</span></code></pre></div><div class=gdoc-page__anchorwrap><h3 id=脏读dirty-reads>脏读（Dirty reads）<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#脏读dirty-reads class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 脏读（Dirty reads）" href=#脏读dirty-reads><svg class="icon link"><use xlink:href="#link"/></svg></a></h3></div><p>一个事务读到另一个事务<strong>未提交</strong>的更新数据。</p><table><thead><tr><th>事务 1 取款事务</th><th>事务 2 工资转账事务</th></tr></thead><tbody><tr><td>开始事务</td><td></td></tr><tr><td></td><td>开始事务</td></tr><tr><td>查询余额 1000 元</td><td></td></tr><tr><td>取出 100 变为 900</td><td></td></tr><tr><td></td><td>查询余额为 900</td></tr><tr><td>异常发生，事务回滚，余额恢复为 1000</td><td></td></tr><tr><td></td><td>汇入工资 2000 元，余额为 2900</td></tr><tr><td></td><td>提交事务，最终余额 2900，损失了 100</td></tr></tbody></table><div class=gdoc-page__anchorwrap><h3 id=不可重复读non-repeatable-reads>不可重复读（Non-Repeatable Reads）<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#不可重复读non-repeatable-reads class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 不可重复读（Non-Repeatable Reads）" href=#不可重复读non-repeatable-reads><svg class="icon link"><use xlink:href="#link"/></svg></a></h3></div><p>在同一个事务内，读取表中的某一行记录，多次读取的结果不同。与幻读区别的重点在于修改，同样的条件，已经读取过的数据，再次读取出来和上一次的值不一样。</p><table><thead><tr><th>事务 1 工资计算</th><th>事务 2 汇款和通知</th></tr></thead><tbody><tr><td></td><td>开始事务</td></tr><tr><td>开始事务</td><td>查询工资 2000 元，通知银行汇款 2000</td></tr><tr><td>增加加班费 6000 元</td><td></td></tr><tr><td>提交事务</td><td></td></tr><tr><td></td><td>再次查询工资应发 8000 元，邮件通知员工本月发了 8000 元</td></tr><tr><td></td><td>提交事务</td></tr></tbody></table><div class=gdoc-page__anchorwrap><h3 id=幻读phantom-reads>幻读(Phantom Reads)<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#幻读phantom-reads class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 幻读(Phantom Reads)" href=#幻读phantom-reads><svg class="icon link"><use xlink:href="#link"/></svg></a></h3></div><p>一个事务读到另一个事务已提交的新插入的数据,导致前后不一致。与不可重复读有点类似，都是两次读取。区别的重点在于增加或者删除。</p><table><thead><tr><th>事务 1 加班录入</th><th>事务 2 加班天数统计，计算加班费</th></tr></thead><tbody><tr><td></td><td>开始事务</td></tr><tr><td>开始事务</td><td>统计员工小明加班 3 天</td></tr><tr><td></td><td>通知银行发 3 天的加班费</td></tr><tr><td>增加一天加班数据</td><td></td></tr><tr><td>提交事务</td><td></td></tr><tr><td></td><td>再次统计加班天数，是 4 天，通知小明发了 4 天的加班费</td></tr><tr><td></td><td>提交事务</td></tr></tbody></table><div class=gdoc-page__anchorwrap><h2 id=事务隔离级别>事务隔离级别<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#事务隔离级别 class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 事务隔离级别" href=#事务隔离级别><svg class="icon link"><use xlink:href="#link"/></svg></a></h2></div><p>事务隔离级别(Transaction Isolation Level)就是对事务并发控制的等级。标准组织 ANSI 定义了四个隔离级别，读未提交 Read uncommitted、读已提交 Read committed、可重复读 Repeatable read、串行化(序列化)Serializable，这四个级别严格程度越来越高，同时并发性能越来越低。</p><div class=gdoc-page__anchorwrap><h3 id=读未提交-read-uncommitted>读未提交 Read uncommitted<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#读未提交-read-uncommitted class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 读未提交 Read uncommitted" href=#读未提交-read-uncommitted><svg class="icon link"><use xlink:href="#link"/></svg></a></h3></div><p>一个事务在执行过程中可以看到其他事务没有提交的记录。</p><div class=gdoc-page__anchorwrap><h3 id=读已提交-read-committed>读已提交 Read committed<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#读已提交-read-committed class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 读已提交 Read committed" href=#读已提交-read-committed><svg class="icon link"><use xlink:href="#link"/></svg></a></h3></div><p>只能读已提交的数据。但是读取的数据可以被其他事务修改，这样也就会导致不可重复读。</p><div class=gdoc-page__anchorwrap><h3 id=可重复读-repeatable-read>可重复读 Repeatable read<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#可重复读-repeatable-read class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 可重复读 Repeatable read" href=#可重复读-repeatable-read><svg class="icon link"><use xlink:href="#link"/></svg></a></h3></div><p>所有被 Select 获取的数据都不能被修改。</p><div class=gdoc-page__anchorwrap><h3 id=序列化-serializable>序列化 Serializable<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#序列化-serializable class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 序列化 Serializable" href=#序列化-serializable><svg class="icon link"><use xlink:href="#link"/></svg></a></h3></div><p>所有事务一个接一个的执行。</p><p>数据库并发问题还有常说的第一类更新丢失、第二类更新丢失，为减少概念复杂度，在这里没有列出来。</p><p>各个隔离级别和问题对应，√: 可能出现，×: 不会出现</p><table><thead><tr><th></th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable read</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>Oracle 和 SqlServer 默认隔离级别是<strong>读已提交</strong>，MySql 默认隔离级别是<strong>可重复读</strong>。</p><p>Oracle 只支持 READ COMMITTED 和 SERIALIZABLE 这两种标准隔离级别，另外增加了一个非标准的“只读(read-only)”隔离级别。顺便提一句，他的 Serializable 隔离级别，并不真正阻塞事务的执行（更深层次的理解另外单说）。</p><p><strong>为避免幻读和不可重复读问题，一般是在一个事务里确保只读取数据一次，而不是提高事务的隔离级别。</strong> 况且 Oracle 也没法设置 Repeatable read。</p><div class=gdoc-page__anchorwrap><h2 id=事务传播行为>事务传播行为<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#事务传播行为 class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 事务传播行为" href=#事务传播行为><svg class="icon link"><use xlink:href="#link"/></svg></a></h2></div><ul><li>PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。Spring 默认的事务传播行为。</li><li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</li><li>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li><li>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</li><li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</li></ul><div class=gdoc-page__anchorwrap><h3 id=嵌套事务>嵌套事务<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#嵌套事务 class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 嵌套事务" href=#嵌套事务><svg class="icon link"><use xlink:href="#link"/></svg></a></h3></div><p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫 save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个 save point。看几个问题就明了了：</p><ul><li>如果子事务回滚，会发生什么？<blockquote><p>父事务会回滚到进入子事务前建立的 save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p></blockquote></li><li>如果父事务回滚，会发生什么？<blockquote><p>父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：</p></blockquote></li><li>事务的提交，是什么情况？<blockquote><p>是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</p></blockquote></li></ul><div class=gdoc-page__anchorwrap><h3 id=只读事务-readonly>只读事务 readOnly<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#只读事务-readonly class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 只读事务 readOnly" href=#只读事务-readonly><svg class="icon link"><use xlink:href="#link"/></svg></a></h3></div><p>概念：从这一点设置的时间点开始到这个事务结束的过程中，其他事务所提交的数据，该事务将看不见。</p><p>应用场合：</p><ol><li>如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；</li><li>如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。</li></ol><p>总结：</p><ol><li>readonly 并不是所有数据库都支持的，不同的数据库下会有不同的结果。</li><li>设置了 readonly 后，connection 都会被赋予 readonly，效果取决于数据库的实现。</li><li>在 ORM 中，设置了 readonly 会赋予一些额外的优化，例如在 Hibernate 中，会被禁止 flush 等。</li><li>由于只读事务不存在数据的修改，因此数据库将会为只读事务提供一些优化手段，例如 Oracle 对于只读事务，不启动回滚段，不记录回滚 log。</li></ol><div class=gdoc-page__anchorwrap><h2 id=spring-声明式事务>Spring 声明式事务<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#spring-声明式事务 class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor Spring 声明式事务" href=#spring-声明式事务><svg class="icon link"><use xlink:href="#link"/></svg></a></h2></div><p>Spring 提供了编程式事务和声明式事务两种机制。为便于理解，简单回顾下 JDBC 和 Hibernate 的事务管理方式。</p><ul><li>JDBC 方式：</li></ul><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Connection</span> <span class=n>conn</span> <span class=o>=</span> <span class=n>DataSourceUtils</span><span class=o>.</span><span class=na>getConnection</span><span class=o>();</span>
<span class=c1>//开启事务
</span><span class=c1></span><span class=n>conn</span><span class=o>.</span><span class=na>setAutoCommit</span><span class=o>(</span><span class=kc>false</span><span class=o>);</span>
<span class=k>try</span> <span class=o>{</span>
  <span class=n>Object</span> <span class=n>retVal</span> <span class=o>=</span>
  <span class=n>callback</span><span class=o>.</span><span class=na>doInConnection</span><span class=o>(</span><span class=n>conn</span><span class=o>);</span>
  <span class=n>conn</span><span class=o>.</span><span class=na>commit</span><span class=o>();</span> <span class=c1>//提交事务
</span><span class=c1></span>  <span class=k>return</span> <span class=n>retVal</span><span class=o>;</span>
<span class=o>}</span><span class=k>catch</span> <span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
  <span class=n>conn</span><span class=o>.</span><span class=na>rollback</span><span class=o>();</span><span class=c1>//回滚事务
</span><span class=c1></span>  <span class=k>throw</span> <span class=n>e</span><span class=o>;</span>
<span class=o>}</span><span class=k>finally</span> <span class=o>{</span>
  <span class=n>conn</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>
<span class=o>}</span>
</code></pre></div><ul><li>Hibernate 方式：</li></ul><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>Session</span> <span class=n>session</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
<span class=n>Transaction</span> <span class=n>transaction</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
<span class=k>try</span> <span class=o>{</span>
  <span class=n>session</span> <span class=o>=</span> <span class=n>factory</span><span class=o>.</span><span class=na>openSession</span><span class=o>();</span>
  <span class=c1>//开启事务
</span><span class=c1></span>  <span class=n>transaction</span> <span class=o>=</span> <span class=n>session</span><span class=o>.</span><span class=na>beginTransaction</span><span class=o>();</span>
  <span class=n>transation</span><span class=o>.</span><span class=na>begin</span><span class=o>();</span>
  <span class=n>session</span><span class=o>.</span><span class=na>save</span><span class=o>(</span><span class=n>user</span><span class=o>);</span>
  <span class=n>transaction</span><span class=o>.</span><span class=na>commit</span><span class=o>();</span><span class=c1>//提交事务
</span><span class=c1></span><span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
  <span class=n>transaction</span><span class=o>.</span><span class=na>rollback</span><span class=o>();</span><span class=c1>//回滚事务
</span><span class=c1></span>  <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
<span class=o>}</span><span class=k>finally</span><span class=o>{</span>
  <span class=n>session</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>
<span class=o>}</span>
</code></pre></div><p>看下 Spring 编程式方式：</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>//1.获取事务管理器
</span><span class=c1></span><span class=n>PlatformTransactionManager</span> <span class=n>txManager</span> <span class=o>=</span><span class=n>ctx</span><span class=o>.</span><span class=na>getBean</span><span class=o>(</span><span class=s>&#34;txManager&#34;</span><span class=o>);</span>
<span class=c1>//2.定义事务属性
</span><span class=c1></span><span class=n>DefaultTransactionDefinition</span> <span class=n>td</span> <span class=o>=</span> <span class=k>new</span> <span class=n>DefaultTransactionDefinition</span><span class=o>();</span>
<span class=n>td</span><span class=o>.</span><span class=na>setIsolationLevel</span><span class=o>(</span><span class=n>TransactionDefinition</span><span class=o>.</span><span class=na>ISOLATION_READ_COMMITTED</span><span class=o>);</span>
<span class=c1>//3开启事务,得到事务状态
</span><span class=c1></span><span class=n>TransactionStatus</span> <span class=n>status</span> <span class=o>=</span> <span class=n>txManager</span><span class=o>.</span><span class=na>getTransaction</span><span class=o>(</span><span class=n>td</span><span class=o>);</span>
<span class=k>try</span> <span class=o>{</span>
  <span class=c1>//4.执行数据库操作
</span><span class=c1></span>  <span class=n>jdbcTempate</span><span class=o>.</span><span class=na>queryForInt</span><span class=o>(</span><span class=s>&#34;select count(*) from tbl_doc&#34;</span><span class=o>);</span>
  <span class=c1>//5、提交事务
</span><span class=c1></span>  <span class=n>txManager</span><span class=o>.</span><span class=na>commit</span><span class=o>(</span><span class=n>status</span><span class=o>);</span>

<span class=o>}</span><span class=k>catch</span> <span class=o>(</span><span class=n>Exception</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
  <span class=c1>//6、回滚事务
</span><span class=c1></span>  <span class=n>txManager</span><span class=o>.</span><span class=na>rollback</span><span class=o>(</span><span class=n>status</span><span class=o>);</span>
<span class=o>}</span>
</code></pre></div><p>可以看到，以上几种方式都比较复杂，需要我们自己处理事务，要做的事情比较多。而 Spring 的声明式事务使用简单，它支持注解和 xml 配置，这里以注解为例。</p><div class=gdoc-page__anchorwrap><h3 id=transactional>@Transactional<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#transactional class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor @Transactional" href=#transactional><svg class="icon link"><use xlink:href="#link"/></svg></a></h3></div><p>Spring 声明式事务的使用，一切都落在注解**@Transactional**上。</p><p>先看一个简单的例子，在实现类的加注解，实现事务控制。</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=o>&lt;!--</span> <span class=n>the</span> <span class=n>service</span> <span class=kd>class</span> <span class=nc>that</span> <span class=n>we</span> <span class=n>want</span> <span class=n>to</span> <span class=n>make</span> <span class=n>transactional</span> <span class=o>--&gt;</span>
<span class=nd>@Transactional</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>DefaultFooService</span> <span class=kd>implements</span> <span class=n>FooService</span> <span class=o>{</span>
  <span class=n>Foo</span> <span class=nf>getFoo</span><span class=o>(</span><span class=n>String</span> <span class=n>fooName</span><span class=o>);</span>
  <span class=n>Foo</span> <span class=nf>getFoo</span><span class=o>(</span><span class=n>String</span> <span class=n>fooName</span><span class=o>,</span> <span class=n>String</span> <span class=n>barName</span><span class=o>);</span>
  <span class=kt>void</span> <span class=nf>insertFoo</span><span class=o>(</span><span class=n>Foo</span> <span class=n>foo</span><span class=o>);</span>
  <span class=kt>void</span> <span class=nf>updateFoo</span><span class=o>(</span><span class=n>Foo</span> <span class=n>foo</span><span class=o>);</span>
<span class=o>}</span>
</code></pre></div><div class=gdoc-page__anchorwrap><h4 id=使用方法>使用方法<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#使用方法 class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 使用方法" href=#使用方法><svg class="icon link"><use xlink:href="#link"/></svg></a></h4></div><ul><li>@Transactional 可用于接口、接口方法、实现类以及类方法上。放在接口或类上，相当于为此接口或类下所有的 public 方法都加了这样一个注解。</li><li>Spring 团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因此，请接受 Spring 团队的建议并且在具体的类上使用@Transactional 注解。</li><li><strong>@Transactional 注解应该只被应用到 public 的方法上。</strong> 如果你在 protected、private 或者 package-visible 的方法上使用，它也不会报错，也不会生效。</li><li>方法的@Transactional 会覆盖类上面声明的事务，也就是方法上的优先级高。</li></ul><div class=gdoc-page__anchorwrap><h4 id=传播行为propagation>传播行为（Propagation）<a data-clipboard-text=https://l10178.github.io/bits-pieces/linux/transaction/#传播行为propagation class="gdoc-page__anchor gdoc-page__anchor--right clip" aria-label="Anchor 传播行为（Propagation）" href=#传播行为propagation><svg class="icon link"><use xlink:href="#link"/></svg></a></h4></div><p>所谓事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。Spring 支持 7 种事务传播行为：</p><ul><li><strong>PROPAGATION_REQUIRED</strong> 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</li><li><strong>PROPAGATION_SUPPORTS</strong> 支持当前事务，如果当前没有事务，就以非事务方式执行。</li><li><strong>PROPAGATION_MANDATORY</strong> 使用当前的事务，如果当前没有事务，就抛出异常。</li><li><strong>PROPAGATION_REQUIRES_NEW</strong> 新建事务，如果当前存在事务，把当前事务挂起。</li><li><strong>PROPAGATION_NOT_SUPPORTED</strong> 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li><strong>PROPAGATION_NEVER</strong> 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li><strong>PROPAGATION_NESTED</strong> 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则开启一个新的事务。PROPAGATION_NESTED 开始一个 &ldquo;嵌套的&rdquo; 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交. 嵌套事务回滚不影响外部事务，但外部事务回滚将导致嵌套事务回滚。 使用嵌套事务需要 JDBC3.0 并且事务管理器开启嵌套事务（常用的 JpaTransactionManager 和 HibernateTransactionManager 默认是不开启的），如果没有开启，运行时将抛出异常。</li></ul><p>举例，现有用户和地址管理，假如每增加一个新用户就需要自动增加一个与此用户相关的地址（这例子真挫，至今没有见到过这样的需求）。那么代码大致是这个样子：</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=c1>//用户管理类
</span><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>UserService</span> <span class=o>{</span>

  <span class=nd>@Resource</span>
  <span class=kd>private</span> <span class=n>UserDao</span> <span class=n>userDao</span><span class=o>;</span>

  <span class=cm>/** 地址管理类 */</span>
  <span class=nd>@Resource</span>
  <span class=kd>private</span> <span class=n>AddressService</span> <span class=n>addressService</span><span class=o>;</span>

  <span class=nd>@Transactional</span>
  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>save</span><span class=o>(</span><span class=n>User</span> <span class=n>user</span><span class=o>){</span>
    <span class=c1>//执行sql保存用户信息
</span><span class=c1></span>    <span class=n>userDao</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>user</span><span class=o>);</span>

    <span class=n>Address</span> <span class=n>address</span><span class=o>=</span><span class=k>new</span> <span class=n>Address</span><span class=o>();</span><span class=c1>//设置地址信息
</span><span class=c1></span>
    <span class=c1>//执行sql保存地址信息
</span><span class=c1></span>    <span class=n>addressService</span><span class=o>.</span><span class=na>save</span><span class=o>(</span><span class=n>address</span><span class=o>);</span>
  <span class=o>}</span>
<span class=o>}</span>

<span class=c1>//测试类
</span><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ApplicationTest</span> <span class=o>{</span>
  <span class=nd>@Resource</span>
  <span class=kd>private</span> <span class=n>UserService</span> <span class=n>userService</span><span class=o>;</span>

  <span class=nd>@Test</span>
  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>transactionalTest</span><span class=o>()</span> <span class=o>{</span>
    <span class=n>User</span> <span class=n>user</span> <span class=o>=</span> <span class=k>new</span> <span class=n>User</span><span class=o>();</span>
    <span class=n>user</span><span class=o>.</span><span class=na>setUsername</span><span class=o>(</span><span class=s>&#34;Test-001&#34;</span><span class=o>);</span>
    <span class=n>userService</span><span class=o>.</span><span class=na>save</span><span class=o>(</span><span class=n>user</span><span class=o>);</span>
  <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>@Transactional 注解加在 UserService.save 和 AddressService.save 两个方法上。</p><p>具体的事务开启和关闭流程，设置 spring 的日志级别为 debug 后，运行，可看到类似于这面这样的日志。这里使用了 Spring data jpa，打印的是 JpaTransactionManager 的日志。UserServices 使用的传播行为是 REQUIRED，AddressService 使用 REQUIRES_NEW。</p><pre><code class=language-log data-lang=log>- Creating new transaction with name [UserService.save]:PROPAGATION_REQUIRED,ISOLATION_DEFAULT; ''
- Opened new EntityManager [org.hibernate.jpa.internal.EntityManagerImpl@16602333] for JPA transaction
- Exposing JPA transaction as JDBC transaction [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@2dd4a7a9]
- Found thread-bound EntityManager [org.hibernate.jpa.internal.EntityManagerImpl@16602333] for JPA transaction
- Participating in existing transaction
- Found thread-bound EntityManager [org.hibernate.jpa.internal.EntityManagerImpl@16602333] for JPA transaction
- Suspending current transaction, creating new transaction with name [AddressService.save]
- Opened new EntityManager [org.hibernate.jpa.internal.EntityManagerImpl@28b7646] for JPA transaction
- Exposing JPA transaction as JDBC transaction [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@40239b34]
- Found thread-bound EntityManager [org.hibernate.jpa.internal.EntityManagerImpl@28b7646] for JPA transaction
- Participating in existing transaction
- Initiating transaction commit
- Committing JPA transaction on EntityManager [org.hibernate.jpa.internal.EntityManagerImpl@28b7646]
- Closing JPA EntityManager [org.hibernate.jpa.internal.EntityManagerImpl@28b7646] after transaction
- Closing JPA EntityManager
- Resuming suspended transaction after completion of inner transaction
- Initiating transaction commit
- Committing JPA transaction on EntityManager [org.hibernate.jpa.internal.EntityManagerImpl@16602333]
- Closing JPA EntityManager [org.hibernate.jpa.internal.EntityManagerImpl@16602333] after transaction
</code></pre></article><div class="gdoc-page__footer flex flex-wrap justify-between"></div></div></main><footer class=gdoc-footer><div class="container flex flex-wrap"><span class=gdoc-footer__item>Copyright © 2020-2022 <a href=https://www.nxest.com class=gdoc-footer__link>nxest.com</a>.</span></div></footer></div><script defer src=/bits-pieces/js/en.search.min.js></script><script defer src=/bits-pieces/js/clipboard.min.js></script><script>document.addEventListener("DOMContentLoaded",function(event){var clipboard=new ClipboardJS('.clip');});</script></body></html>