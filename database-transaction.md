# 数据库事务
数据库事务总结，主要包括数据库事务ACID属性介绍、数据库并发问题总结、事务传播行为和隔离级别。

# 概念
事务（Transaction）是并发控制的基本单位。它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。标准定义：指作为单个逻辑工作单元执行的一系列操作，而这些逻辑工作单元需要具有原子性，  一致性，隔离性和持久性四个属性，统称为ACID特性。
#### Atomic（原子性）
事务中包含的操作被看做一个不可分割的逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。
#### Consistency（一致性）
事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。关于数据库一致性，更专业的解释请参考专业的书籍。
#### Isolation（隔离性）
事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。
#### Durability（持久性）
事务提交后，对系统的影响是永久的。简单理解就是写进去了，不会因为时间、系统环境，关机重启等变化而变化。

# 数据库并发问题
数据库是共享资源，通常有许多个事务同时在运行。当多个事务并发地存取数据库时就会产生同时读取和（或）修改同一数据的情况。若对并发操作不加控制就可能会存取和存储不正确的数据，破坏数据库的一致性。所以数据库管理系统必须提供并发控制机制。

并发操作一般可能带来以下几种问题。为说明问题，先来准备一个例子，假设现在有一个账户表TBL_BANK_ACCOUNT。
```sql
CREATE TABLE TBL_BANK_ACCOUNT（
AccountId CHAR(4) NOT NULL, -- 银行账号
Username NVARCHAR(63) NOT NULL, -- 用户名
Balance BIGINT NOT NULL -- 余额
)
INSERT INTO TBL_BANK_ACCOUNT
VALUES ('9555', '小明', 1000) -- 北京分行账号
INSERT INTO dbo.BankAccount
VALUES ('9556', '小明', 2000) -- 上海分行账号
```

#### 脏读（Dirty reads）
一个事务读到另一个事务**未提交**的更新数据。

| 事务1 取款事务 | 事务2 工资转账事务 |
| -- | -- |
| 开始事务      |  |
|             | 开始事务 |
|查询余额1000元 | |
|取出100变为900 |  |
|             |  查询余额为900|
|异常发生，事务回滚，余额恢复为1000 |  |
|             |汇入工资2000元，余额为2900|
|             | 提交事务，最终余额2900，损失了100|

#### 不可重复读（Non-Repeatable Reads）
在同一个事务内，读取表中的某一行记录，多次读取的结果不同。与幻读区别的重点在于修改，同样的条件，已经读取过的数据，再次读取出来和上一次的值不一样。

| 事务1 工资计算 | 事务2 汇款和通知 |
| -- | -- |
|    |  开始事务 |
| 开始事务 | 查询工资2000元，通知银行汇款2000 |
|增加加班费6000元 |  |
| 提交事务       | |
|              |再次查询工资应发8000元，邮件通知员工本月发了8000元 |
|              | 提交事务|

#### 幻读(Phantom Reads)
一个事务读到另一个事务已提交的新插入的数据,导致前后不一致。与不可重复读有点类似，都是两次读取。区别的重点在于增加或者删除。

| 事务1 加班录入 | 事务2 加班天数统计，计算加班费 |
| -- | -- |
|      | 开始事务 |
| 开始事务 | 统计员工小明加班3天 |
|             | 通知银行发3天的加班费|
|增加一天加班数据|  |
|提交事务 |  |
|        | 再次统计加班天数，是4天，通知小明发了4天的加班费 |
|              |提交事务 |

# 事务隔离级别
事务隔离级别(Transaction Isolation Level)就是对事务并发控制的等级。标准组织ANSI定义了四个隔离级别，读未提交Read uncommitted、读已提交Read committed、可重复读Repeatable read、串行化(序列化)Serializable，这四个级别严格程度越来越高，同时并发性能越来越低。

#### 读未提交Read uncommitted
一个事务在执行过程中可以看到其他事务没有提交的记录。
#### 读已提交Read committed
只能读已提交的数据。但是读取的数据可以被其他事务修改，这样也就会导致不可重复读。
#### 可重复读Repeatable read
所有被Select获取的数据都不能被修改。
#### 序列化Serializable
所有事务一个接一个的执行。

如果有可能，在学习数据库锁机制的时候，介绍下几种隔离级别的实现原理。另外数据库并发问题还有常说的第一类更新丢失、第二类更新丢失，为减少概念复杂度，在这里没有列出来。

各个隔离级别和问题对应，√: 可能出现，×: 不会出现

|  | 脏读 | 不可重复读|幻读|
| -- | -- | -- | -- |
| Read uncommitted | √ |√ |√ |
| Read committed | × |√ |√ |
|  Repeatable read  | × | × |√ |
|Serializable| × | × |× |

Oracle和SqlServer默认隔离级别是**读已提交**，MySql默认隔离级别是**可重复读**。

Oracle只支持READ COMMITTED和SERIALIZABLE这两种标准隔离级别，另外增加了一个非标准的“只读(read-only)”隔离级别。顺便提一句，他的Serializable隔离级别，并不真正阻塞事务的执行（更深层次的理解另外单说）。

**为避免幻读和不可重复读问题，一般是在一个事务里确保只读取数据一次，而不是提高事务的隔离级别。** 况且Oracle也没法设置Repeatable read。

# 事务传播行为
待补充
